#!/usr/bin/perl -w -Ilib
use Carp;
use Getopt::Long;
use WWW::Challonge;
use XML::Simple;
use strict;
use Data::Dumper;

use KTS::Tournament;
use KTS::Tournament::TournMatch;
use KTS::Tournament::TournPlayer;
use KTS::Tournament::TournPlayer::Player;

sub main;
sub usage;

# Process command-line arguments:
my $help = ""; # Print usage (true / false)
my $auth = ""; # Challonge API key
my $turl = ""; # Challonge tournament URL
my $outf = ""; # Output filename
my $loct = ""; # Locations.XML file path
my $play = ""; # Players.XML file path
my $tid =  ""; # Tournament ID
GetOptions(
	"help" => \$help,
	"api-key=s" => \$auth,
	"tournament=s" => \$turl,
	"output=s" => \$outf,
	"locations=s" => \$loct,
	"players=s" => \$play,
	"id=s" => \$tid
) or usage;

# Get the players and return them mapped by their Challonge ID
sub players
{
	my ($t, $players_xml) = @_;
	my $challonge_players = $t->participants;

	# The first temporary COSSY ID. They then increment, so the next one is
	# 9999000001, etc.
	my $temp = 9999000000;

	# If supplied with the Players.XML file, attempt to make an educated guess
	# as to players and thus their IDs. Otherwise, will require manual input:
	# TODO: Implement this:
	my %players;
	for my $player (@{$challonge_players})
	{
		# Get the player's name (must be First Last):
		my $name = "";
		do
		{
			print "Full name of '", $player->attributes->{"name"}, "': ";
			chomp($name = <STDIN>);
		} while($name !~ /^[A-Z][a-z]* [A-Z][a-z]*$/);

		# Get the player's COSSY ID (must be a ten-digit number):
		my $cossy = "";
		do
		{
			print "COSSY ID: ";
			chomp($cossy = <STDIN>);
			# If a temp ID is used, set that:
			$cossy = $temp++ if($cossy eq "temp");
		} while($cossy !~ /^\d{10}$/);
		print "\n";

		# Make a player object from this:
		$players{$player->attributes->{"id"}} = 
			KTS::Tournament::TournPlayer::Player->new(
			"FirstName" => (split(" ", $name))[0],
			"LastName" => (split(" ", $name))[1],
			"ID" => $cossy,
		);
	}
	return \%players;
}

# Transform the matches to TournMatches:
sub matches
{
	my ($t, $players) = @_;
	my $challonge_matches = $t->matches;

	# TODO: Table number and tie rounds

	my %matches;
	for my $match (@{$challonge_matches})
	{
		$matches{$match->attributes->{"id"}} =
			KTS::Tournament::TournMatch->new(
			"Players" => [
				$players->{$match->attributes->{"player1_id"}}->id,
				$players->{$match->attributes->{"player2_id"}}->id
			],
			"Round" => $match->attributes->{"round"},
			"Winner" => $players->{$match->attributes->{"winner_id"}}->id,
		);
	}
	return \%matches;
}

# Transforms players into a list of TournPlayers:
sub tournplayers
{
	my ($t, $players) = @_;

	# Calculate number of wins for each player:
	my $participants = $t->participants;
	my $matches = $t->matches;
	my %wins;
	for my $match (@{$matches})
	{
		$wins{$match->attributes->{"winner_id"}}++;
	}

	my %tournplayers;
	for my $player (@{$participants})
	{
		$tournplayers{$player->attributes->{"id"}} =
			KTS::Tournament::TournPlayer->new(
			"Player" => $players->{$player->attributes->{"id"}},
			"Rank" => $player->attributes->{"final_rank"},
			"Wins" => $wins{$player->attributes->{"id"}} * 3 // 0,
		);
	}
	return \%tournplayers;
}

sub main
{
	# Check the Challonge API key and URL are supplied:
	die "Must supply a Challonge API key with -a\n" if($auth eq "");
	die "Must supply a Challonge tournament URL with -t\n" if($turl eq "");

	# Create Challonge connection and get tournament:
	my $c = WWW::Challonge->new($auth);
	my $t = $c->tournament($turl);
	my $p = players($t);
	my $m = matches($t, $p);
	my $tp = tournplayers($t, $p);
	print Dumper $tp;
}

sub usage
{
}

main;
