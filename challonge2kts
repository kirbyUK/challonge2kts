#!/usr/bin/perl -w -Ilib
use strict;
use Carp;
use Getopt::Long;
use DateTime::Format::ISO8601;
use WWW::Challonge;
use XML::Writer;

use KTS::Tournament;
use KTS::Tournament::TournMatch;
use KTS::Tournament::TournPlayer;
use KTS::Tournament::TournPlayer::Player;

sub main;
sub usage;

# Process command-line arguments:
my $help = ""; # Print usage (true / false)
my $auth = ""; # Challonge API key
my $turl = ""; # Challonge tournament URL
my $outf = ""; # Output filename
my $loct = ""; # Locations.XML file path
my $play = ""; # Players.XML file path
my $tid =  ""; # Tournament ID
GetOptions(
	"help" => \$help,
	"api-key=s" => \$auth,
	"tournament=s" => \$turl,
	"output=s" => \$outf,
#	"locations=s" => \$loct,
#	"players=s" => \$play,
	"id=s" => \$tid
) or usage;

# Get the players and return them mapped by their Challonge ID
sub players
{
	my ($t, $players_xml) = @_;
	my $challonge_players = $t->participants;

	# The first temporary COSSY ID. They then increment, so the next one is
	# 9999000001, etc.
	my $temp = 9999000000;

	# If supplied with the Players.XML file, attempt to make an educated guess
	# as to players and thus their IDs. Otherwise, will require manual input:
	# TODO: Implement this:
	my %players;
	for my $player (@{$challonge_players})
	{
		# Get the player's name (must be First Last):
		my $name = "";
		do
		{
			print "Full name of '", $player->attributes->{"name"}, "': ";
			chomp($name = <STDIN>);
		} while($name !~ /^[A-Z][a-z]* [A-Z][a-z]*$/);

		# Get the player's COSSY ID (must be a ten-digit number):
		my $cossy = "";
		do
		{
			print "COSSY ID: ";
			chomp($cossy = <STDIN>);
			# If a temp ID is used, set that:
			$cossy = $temp++ if($cossy eq "temp");
		} while($cossy !~ /^\d{10}$/);
		print "\n";

		# Make a player object from this:
		$players{$player->attributes->{"id"}} = 
			KTS::Tournament::TournPlayer::Player->new(
			"FirstName" => (split(" ", $name))[0],
			"LastName" => (split(" ", $name))[1],
			"ID" => $cossy,
		);
	}
	return \%players;
}

# Transforms players into a list of TournPlayers:
sub tournplayers
{
	my ($t, $players) = @_;

	# Calculate number of wins for each player:
	my $participants = $t->participants;
	my $matches = $t->matches;
	my %wins;
	for my $match (@{$matches})
	{
		$wins{$match->attributes->{"winner_id"}}++;
	}

	my @tournplayers;
	for my $player (@{$participants})
	{
		push @tournplayers, KTS::Tournament::TournPlayer->new(
			"Player" => $players->{$player->attributes->{"id"}},
			"Rank" => $player->attributes->{"final_rank"},
			"Wins" => ($wins{$player->attributes->{"id"}} // 0) * 3,
		);
	}
	return \@tournplayers;
}

# Take an arrayref of WWW::Challonge::Match objects and split them by round
# number:
sub matches_by_round
{
	my $matches = shift;
	my $matches_by_round = { };
	for my $match (@{$matches})
	{
		# Different method calls are needed depending on the object type used:
		if (ref $match eq "WWW::Challonge::Match")
		{
			push @{$matches_by_round->{$match->attributes->{"round"}}}, $match;
		}
		elsif (ref $match eq "KTS::Tournament::TournMatch")
		{
			push @{$matches_by_round->{$match->round}}, $match;
		}
		else
		{
			die "Unknown reference type '", ref $match, "'\n";
		}
	}
	return $matches_by_round;
}

# Work out the bye matches for each round and make TournMatch objects of them:
sub byes
{
	my ($challonge_matches, $players) = @_;

	my %matches_by_round = %{matches_by_round($challonge_matches)};

	# Find the missing player for each round and make a new TournMatch for them:
	my @byes;
	for my $round (keys %matches_by_round)
	{
		# Get all the players that are in this round:
		my @playing;
		for my $match (@{$matches_by_round{$round}})
		{
			my $attr = $match->attributes;
			push @playing, $attr->{"player1_id"};
			push @playing, $attr->{"player2_id"};
		}

		# Calculate the difference between the players in the round and the list
		# of all players (perlfaq4):
		my %count;
		my @diff;
		my @players_c = keys %{$players};
		for my $elem (@playing, @players_c) { $count{$elem}++; }
		for my $elem (keys %count) { push @diff, $elem if($count{$elem} < 2); }

		# Make a new round for each player with a bye:
		for my $player (@diff)
		{
			push @byes, KTS::Tournament::TournMatch->new(
				"Players" => [ $players->{$player}->id, "0" ],
				"Round" => $round,
				"Winner" => "0",
			);
		}
	}
	return \@byes;
}

# Work out the table numbers for each round:
sub tables
{
	my $matches = shift;

	my %matches_by_round = %{matches_by_round($matches)};

	my %wins;
	$wins{0} = -1000; # This should be small enough?
	for my $round (keys %matches_by_round)
	{
		my $i = 1;
		for my $match (sort {
			(($wins{$b->players->[0]} // 0) + ($wins{$b->players->[1]} // 0))
			<=>
			(($wins{$a->players->[0]} // 0) + ($wins{$a->players->[1]} // 0))
		} @{$matches_by_round{$round}})
		{
			$wins{$match->winner}++;
			$match->set_table($i++);
		}
	}
}

# Transform the matches to TournMatches:
sub matches
{
	my ($t, $players) = @_;
	my $challonge_matches = $t->matches;

	# TODO: Tie rounds

	my @matches;
	for my $match (@{$challonge_matches})
	{
		push @matches, KTS::Tournament::TournMatch->new(
			"Players" => [
				$players->{$match->attributes->{"player1_id"}}->id,
				$players->{$match->attributes->{"player2_id"}}->id
			],
			"Round" => $match->attributes->{"round"},
			"Winner" => $players->{$match->attributes->{"winner_id"}}->id,
		);
	}
	push @matches, @{byes($challonge_matches, $players)}
		unless((keys %{$players}) % 2 == 0);
	tables(\@matches);
	return \@matches;
}

# Pulls together all tournament data into a KTS::Tournament object:
sub tournament
{
	my ($t, $tournplayers, $tournmatches) = @_;

	# Get the time and date:
	my $dt = DateTime::Format::ISO8601->parse_datetime(
		$t->attributes->{"started_at"}
	);

	return KTS::Tournament->new(
		"Name" => $t->attributes->{"name"},
		"ID" => $tid || "X99-000001",
		"Date" => $dt->date,
		"Time" => $dt->hour . ":" . $dt->minute,
		"CurrentRound" => $t->attributes->{"swiss_rounds"},
		"TournamentPlayers" => [
			sort { $a->id <=> $b->id }
			@{$tournplayers}
		],
		"Matches" => [
			sort { $a->round <=> $b->round or $a->table <=> $b->table }
			@{$tournmatches}
		],
	);
}

sub main
{
	# Check the Challonge API key and URL are supplied:
	die "Must supply a Challonge API key with -a\n" if($auth eq "");
	die "Must supply a Challonge tournament URL with -t\n" if($turl eq "");

	# Create Challonge connection and get tournament:
	my $c = WWW::Challonge->new($auth);
	my $t = $c->tournament($turl);
	my $p = players($t);
	my $m = matches($t, $p);
	my $tp = tournplayers($t, $p);
	my $tourn = tournament($t, $tp, $m);

	# Create the XML document:
	my $doc = new XML::Writer(
		ENCODING => "utf-8",
		OUTPUT => "self",
		DATA_MODE => "true",
		DATA_INDENT => 4
	);
	$doc->xmlDecl;
	$doc = $tourn->toXML($doc);
	$doc->end;

	# Write the file:
	my $filename = $outf || $tourn->name . " (ID " . $tourn->id . ").Tournament";
	open my $fh, '>', $filename or die "Cannot open '$filename': $!\n";
	print $fh $doc->to_string;
	close $fh;
}

sub usage
{
	print "usage: challonge2kts -a [api key] -t [tournament link] [OPTIONS]\n\n";
	print "-a s or --api-key=s\tThe Challonge API key.\n",
			"\t\t\tRequired, but does not have to be the\n",
			"\t\t\taccount that owns the tournament\n\n";
	print "-h or --help\t\tPrint this help message\n\n";
	print "-i s or --id=s\t\tThe ID of the tournament. Defaults to\n",
			"\t\t\tX99-000001\n\n";
	print "-o s or --output=s\tThe output filename. Defaults to the\n",
			"\t\t\tsame style as KTS\n\n";
	print "-t s or --tournament=s\tThe URL of the Challonge tournament.\n",
			"\t\t\tRequired.\n";
}

if ($help) { usage; } else { main };
